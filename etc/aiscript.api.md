## API Report File for "@akkohq/aiscript"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// Warning: (ae-forgotten-export) The symbol "NodeBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AddAssign = NodeBase & {
    dest: Expression;
    expr: Expression;
    type: 'addAssign';
};

// Warning: (ae-forgotten-export) The symbol "NodeBase_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AddAssign_2 = NodeBase_2 & {
    dest: Expression_2;
    expr: Expression_2;
    type: 'addAssign';
};

// @public (undocumented)
abstract class AiScriptError extends Error {
    constructor(message: string, info?: any);
    // (undocumented)
    info?: any;
    // (undocumented)
    name: string;
}

// @public
class AiScriptIndexOutOfRangeError extends AiScriptRuntimeError {
    constructor(message: string, info?: any);
}

// @public
class AiScriptRuntimeError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public
class AiScriptSyntaxError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public
class AiScriptTypeError extends AiScriptError {
    constructor(message: string, info?: any);
    // (undocumented)
    name: string;
}

// @public (undocumented)
type And = NodeBase & {
    left: Expression;
    right: Expression;
    type: 'and';
};

// @public (undocumented)
type And_2 = NodeBase_2 & {
    left: Expression_2;
    right: Expression_2;
    type: 'and';
};

// @public (undocumented)
const ARR: (arr: VArr['value']) => VArr;

// @public (undocumented)
type Arr = NodeBase & {
    type: 'arr';
    value: Expression[];
};

// Warning: (ae-forgotten-export) The symbol "ChainProp" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Arr_2 = NodeBase_2 & ChainProp & {
    type: 'arr';
    value: Expression_2[];
};

// @public (undocumented)
function assertArray(value: Value | null | undefined): asserts value is VArr;

// @public (undocumented)
function assertBoolean(value: Value | null | undefined): asserts value is VBool;

// @public (undocumented)
function assertFunction(value: Value | null | undefined): asserts value is VFn;

// @public (undocumented)
function assertNumber(value: Value | null | undefined): asserts value is VNum;

// @public (undocumented)
function assertObject(value: Value | null | undefined): asserts value is VObj;

// @public (undocumented)
function assertString(value: Value | null | undefined): asserts value is VStr;

// @public (undocumented)
type Assign = NodeBase & {
    dest: Expression;
    expr: Expression;
    type: 'assign';
};

// @public (undocumented)
type Assign_2 = NodeBase_2 & {
    dest: Expression_2;
    expr: Expression_2;
    type: 'assign';
};

declare namespace AST {
    export {
        AddAssign,
        And,
        Arr,
        Assign,
        Attribute,
        Block,
        Bool,
        Break,
        Call,
        Continue,
        Definition,
        Each,
        Exists,
        Expression,
        Fn,
        FnTypeSource,
        For,
        Identifier,
        If,
        Index,
        LOC,
        Loop,
        Match,
        Meta,
        NamedTypeSource,
        Namespace,
        Node,
        Not,
        Null,
        Num,
        Obj,
        Or,
        Prop,
        Return,
        Statement,
        Str,
        SubAssign,
        Tmpl,
        TypeSource
    }
}
export { AST }

// @public (undocumented)
type Attr = {
    attr?: {
        name: string;
        value: Value;
    }[];
};

// @public (undocumented)
type Attribute = NodeBase & {
    name: string;
    type: 'attr';
    value: Expression;
};

// @public (undocumented)
type Attribute_2 = NodeBase_2 & {
    name: string;
    type: 'attr';
    value: Expression_2;
};

// @public (undocumented)
type Block = NodeBase & {
    statements: (Expression | Statement)[];
    type: 'block';
};

// @public (undocumented)
type Block_2 = NodeBase_2 & ChainProp & {
    statements: (Expression_2 | Statement_2)[];
    type: 'block';
};

// @public (undocumented)
const BOOL: (bool: VBool['value']) => VBool;

// @public (undocumented)
type Bool = NodeBase & {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type Bool_2 = NodeBase_2 & ChainProp & {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
const BREAK: () => Value;

// @public (undocumented)
type Break = NodeBase & {
    type: 'break';
};

// @public (undocumented)
type Break_2 = NodeBase_2 & {
    type: 'break';
};

// @public (undocumented)
function CALL(target: Call_2['target'], args: Call_2['args'], loc?: {
    end: number;
    start: number;
}): Call_2;

// @public (undocumented)
type Call = NodeBase & {
    args: Expression[];
    target: Expression;
    type: 'call';
};

// @public (undocumented)
type Call_2 = NodeBase_2 & {
    args: Expression_2[];
    target: Expression_2;
    type: 'call';
};

// @public (undocumented)
type CallChain = NodeBase_2 & {
    args: Expression_2[];
    type: 'callChain';
};

// @public (undocumented)
type ChainMember = CallChain | IndexChain | PropChain;

// @public (undocumented)
const CONTINUE: () => Value;

// @public (undocumented)
type Continue = NodeBase & {
    type: 'continue';
};

// @public (undocumented)
type Continue_2 = NodeBase_2 & {
    type: 'continue';
};

declare namespace CST {
    export {
        CALL,
        hasChainProp,
        INDEX,
        isExpression,
        isStatement,
        PROP,
        AddAssign_2 as AddAssign,
        And_2 as And,
        Arr_2 as Arr,
        Assign_2 as Assign,
        Attribute_2 as Attribute,
        Block_2 as Block,
        Bool_2 as Bool,
        Break_2 as Break,
        Call_2 as Call,
        CallChain,
        ChainMember,
        Continue_2 as Continue,
        Definition_2 as Definition,
        Each_2 as Each,
        Exists_2 as Exists,
        Expression_2 as Expression,
        Fn_2 as Fn,
        FnTypeSource_2 as FnTypeSource,
        For_2 as For,
        Identifier_2 as Identifier,
        If_2 as If,
        Index_2 as Index,
        IndexChain,
        Infix,
        InfixOperator,
        Loop_2 as Loop,
        Match_2 as Match,
        Meta_2 as Meta,
        NamedTypeSource_2 as NamedTypeSource,
        Namespace_2 as Namespace,
        Node_2 as Node,
        Null_2 as Null,
        Num_2 as Num,
        Obj_2 as Obj,
        Or_2 as Or,
        Not_2 as Not,
        Prop_2 as Prop,
        PropChain,
        Return_2 as Return,
        Statement_2 as Statement,
        Str_2 as Str,
        SubAssign_2 as SubAssign,
        Tmpl_2 as Tmpl,
        TypeSource_2 as TypeSource
    }
}
export { CST }

// @public (undocumented)
type Definition = NodeBase & {
    attr: Attribute[];
    expr: Expression;
    mut: boolean;
    name: string;
    type: 'def';
    varType?: TypeSource;
};

// @public (undocumented)
type Definition_2 = NodeBase_2 & {
    attr?: Attribute_2[];
    expr: Expression_2;
    mut: boolean;
    name: string;
    type: 'def';
    varType?: TypeSource_2;
};

// @public (undocumented)
type Each = NodeBase & {
    for: Expression | Statement;
    items: Expression;
    type: 'each';
    var: string;
};

// @public (undocumented)
type Each_2 = NodeBase_2 & {
    for: Expression_2 | Statement_2;
    items: Expression_2;
    type: 'each';
    var: string;
};

// @public (undocumented)
function eq(a: Value, b: Value): boolean;

// @public (undocumented)
const ERROR: (name: string, info?: Value) => Value;

declare namespace Errors {
    export {
        AiScriptError,
        AiScriptRuntimeError,
        AiScriptSyntaxError,
        AiScriptTypeError,
        NonAiScriptError,
        AiScriptIndexOutOfRangeError
    }
}
export { Errors }

// @public (undocumented)
type Exists = NodeBase & {
    identifier: Identifier;
    type: 'exists';
};

// @public (undocumented)
type Exists_2 = NodeBase_2 & ChainProp & {
    identifier: Identifier_2;
    type: 'exists';
};

// @public (undocumented)
function expectAny(value: Value | null | undefined): asserts value is Value;

// @public (undocumented)
type Expression = And | Arr | Block | Bool | Call | Exists | Fn | Identifier | If | Index | Match | Not | Null | Num | Obj | Or | Prop | Str | Tmpl;

// @public (undocumented)
type Expression_2 = And_2 | Arr_2 | Block_2 | Bool_2 | Call_2 | Exists_2 | Fn_2 | Identifier_2 | If_2 | Index_2 | Infix | Match_2 | Not_2 | Null_2 | Num_2 | Obj_2 | Or_2 | Prop_2 | Str_2 | Tmpl_2;

// @public (undocumented)
const FALSE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
const FN: (args: VFn['args'], statements: VFn['statements'], scope: VFn['scope']) => VFn;

// @public (undocumented)
type Fn = NodeBase & {
    args: {
        argType?: TypeSource;
        name: string;
    }[];
    children: (Expression | Statement)[];
    retType?: TypeSource;
    type: 'fn';
};

// @public (undocumented)
type Fn_2 = NodeBase_2 & ChainProp & {
    args: {
        argType?: TypeSource_2;
        name: string;
    }[];
    children: (Expression_2 | Statement_2)[];
    retType?: TypeSource_2;
    type: 'fn';
};

// @public (undocumented)
const FN_NATIVE: (fn: VFn['native']) => VFn;

// @public (undocumented)
type FnTypeSource = NodeBase & {
    args: TypeSource[];
    result: TypeSource;
    type: 'fnTypeSource';
};

// @public (undocumented)
type FnTypeSource_2 = NodeBase_2 & {
    args: TypeSource_2[];
    result: TypeSource_2;
    type: 'fnTypeSource';
};

// @public (undocumented)
type For = NodeBase & {
    for: Expression | Statement;
    from?: Expression;
    times?: Expression;
    to?: Expression;
    type: 'for';
    var?: string;
};

// @public (undocumented)
type For_2 = NodeBase_2 & {
    for?: Expression_2 | Statement_2;
    from?: Expression_2;
    times?: Expression_2;
    to?: Expression_2;
    type: 'for';
    var?: string;
};

// @public (undocumented)
function getLangVersion(input: string): string | null;

// @public (undocumented)
function hasChainProp<T extends Node_2>(x: T): x is T & ChainProp;

// @public (undocumented)
type Identifier = NodeBase & {
    name: string;
    type: 'identifier';
};

// @public (undocumented)
type Identifier_2 = NodeBase_2 & ChainProp & {
    name: string;
    type: 'identifier';
};

// @public (undocumented)
type If = NodeBase & {
    cond: Expression;
    else?: Expression | Statement;
    elseif: {
        cond: Expression;
        then: Expression | Statement;
    }[];
    then: Expression | Statement;
    type: 'if';
};

// @public (undocumented)
type If_2 = NodeBase_2 & {
    cond: Expression_2;
    else?: Expression_2 | Statement_2;
    elseif: {
        cond: Expression_2;
        then: Expression_2 | Statement_2;
    }[];
    then: Expression_2 | Statement_2;
    type: 'if';
};

// @public (undocumented)
function INDEX(target: Index_2['target'], index: Index_2['index'], loc?: {
    end: number;
    start: number;
}): Index_2;

// @public (undocumented)
type Index = NodeBase & {
    index: Expression;
    target: Expression;
    type: 'index';
};

// @public (undocumented)
type Index_2 = NodeBase_2 & {
    index: Expression_2;
    target: Expression_2;
    type: 'index';
};

// @public (undocumented)
type IndexChain = NodeBase_2 & {
    index: Expression_2;
    type: 'indexChain';
};

// @public (undocumented)
type Infix = NodeBase_2 & {
    operands: Expression_2[];
    operators: InfixOperator[];
    type: 'infix';
};

// @public (undocumented)
type InfixOperator = '||' | '&&' | '==' | '!=' | '<=' | '>=' | '<' | '>' | '+' | '-' | '*' | '^' | '/' | '%';

// @public (undocumented)
export class Interpreter {
    constructor(consts: Record<string, Values.Value>, opts?: Interpreter['opts']);
    // (undocumented)
    abort(): void;
    // (undocumented)
    static collectMetadata(script?: AST.Node[]): Map<string, any> | undefined;
    // (undocumented)
    exec(script?: AST.Node[]): Promise<void>;
    execFn(fn: Values.VFn, args: Values.Value[]): Promise<Values.Value>;
    execFnSimple(fn: Values.VFn, args: Values.Value[]): Promise<Values.Value>;
    // (undocumented)
    registerAbortHandler(handler: () => void): void;
    // (undocumented)
    scope: Scope;
    // (undocumented)
    stepCount: number;
    // (undocumented)
    unregisterAbortHandler(handler: () => void): void;
}

// @public (undocumented)
function isArray(value: Value): value is VArr;

// @public (undocumented)
function isBoolean(value: Value): value is VBool;

// @public (undocumented)
function isExpression(x: Node_2): x is Expression_2;

// @public (undocumented)
function isFunction(value: Value): value is VFn;

// @public (undocumented)
function isNumber(value: Value): value is VNum;

// @public (undocumented)
function isObject(value: Value): value is VObj;

// @public (undocumented)
function isStatement(x: Node_2): x is Statement_2;

// @public (undocumented)
function isString(value: Value): value is VStr;

// @public (undocumented)
function jsToVal(value: any): Value;

// @public (undocumented)
type LOC = {
    end: number;
    start: number;
};

// @public (undocumented)
type Loop = NodeBase & {
    statements: (Expression | Statement)[];
    type: 'loop';
};

// @public (undocumented)
type Loop_2 = NodeBase_2 & {
    statements: (Expression_2 | Statement_2)[];
    type: 'loop';
};

// @public (undocumented)
type Match = NodeBase & {
    about: Expression;
    default?: Expression | Statement;
    qs: {
        a: Expression | Statement;
        q: Expression;
    }[];
    type: 'match';
};

// @public (undocumented)
type Match_2 = NodeBase_2 & ChainProp & {
    about: Expression_2;
    default?: Expression_2 | Statement_2;
    qs: {
        a: Expression_2 | Statement_2;
        q: Expression_2;
    }[];
    type: 'match';
};

// @public (undocumented)
type Meta = NodeBase & {
    name: string | null;
    type: 'meta';
    value: Expression;
};

// @public (undocumented)
type Meta_2 = NodeBase_2 & {
    name: string | null;
    type: 'meta';
    value: Expression_2;
};

// @public (undocumented)
type NamedTypeSource = NodeBase & {
    inner?: TypeSource;
    name: string;
    type: 'namedTypeSource';
};

// @public (undocumented)
type NamedTypeSource_2 = NodeBase_2 & {
    inner?: TypeSource_2;
    name: string;
    type: 'namedTypeSource';
};

// @public (undocumented)
type Namespace = NodeBase & {
    members: (Definition | Namespace)[];
    name: string;
    type: 'ns';
};

// @public (undocumented)
type Namespace_2 = NodeBase_2 & {
    members: (Definition_2 | Namespace_2)[];
    name: string;
    type: 'ns';
};

// @public (undocumented)
type Node = Expression | Meta | Namespace | Statement | TypeSource;

// @public (undocumented)
type Node_2 = ChainMember | Expression_2 | Meta_2 | Namespace_2 | Statement_2 | TypeSource_2;

// @public
class NonAiScriptError extends AiScriptError {
    constructor(error: any);
    // (undocumented)
    name: string;
}

// @public (undocumented)
type Not = NodeBase & {
    expr: Expression;
    type: 'not';
};

// @public (undocumented)
type Not_2 = NodeBase_2 & {
    expr: Expression_2;
    type: 'not';
};

// @public (undocumented)
const NULL: {
    type: "null";
};

// @public (undocumented)
type Null = NodeBase & {
    type: 'null';
};

// @public (undocumented)
type Null_2 = NodeBase_2 & ChainProp & {
    type: 'null';
};

// @public (undocumented)
const NUM: (num: VNum['value']) => VNum;

// @public (undocumented)
type Num = NodeBase & {
    type: 'num';
    value: number;
};

// @public (undocumented)
type Num_2 = NodeBase_2 & ChainProp & {
    type: 'num';
    value: number;
};

// @public (undocumented)
const OBJ: (obj: VObj['value']) => VObj;

// @public (undocumented)
type Obj = NodeBase & {
    type: 'obj';
    value: Map<string, Expression>;
};

// @public (undocumented)
type Obj_2 = NodeBase_2 & ChainProp & {
    type: 'obj';
    value: Map<string, Expression_2>;
};

// @public (undocumented)
type Or = NodeBase & {
    left: Expression;
    right: Expression;
    type: 'or';
};

// @public (undocumented)
type Or_2 = NodeBase_2 & {
    left: Expression_2;
    right: Expression_2;
    type: 'or';
};

// @public (undocumented)
export class Parser {
    constructor();
    // (undocumented)
    addPlugin(type: PluginType, plugin: ParserPlugin): void;
    // (undocumented)
    parse(input: string): AST.Node[];
    // (undocumented)
    static parse(input: string): AST.Node[];
}

// @public (undocumented)
export type ParserPlugin = (nodes: CST.Node[]) => CST.Node[];

// @public (undocumented)
export type PluginType = 'transform' | 'validate';

// @public (undocumented)
function PROP(target: Prop_2['target'], name: Prop_2['name'], loc?: {
    end: number;
    start: number;
}): Prop_2;

// @public (undocumented)
type Prop = NodeBase & {
    name: string;
    target: Expression;
    type: 'prop';
};

// @public (undocumented)
type Prop_2 = NodeBase_2 & {
    name: string;
    target: Expression_2;
    type: 'prop';
};

// @public (undocumented)
type PropChain = NodeBase_2 & {
    name: string;
    type: 'propChain';
};

// @public (undocumented)
function reprValue(value: Value, literalLike?: boolean, processedObjects?: Set<object>): string;

// @public (undocumented)
const RETURN: (value: VReturn['value']) => Value;

// @public (undocumented)
type Return = NodeBase & {
    expr: Expression;
    type: 'return';
};

// @public (undocumented)
type Return_2 = NodeBase_2 & {
    expr: Expression_2;
    type: 'return';
};

// @public (undocumented)
export class Scope {
    constructor(layeredStates?: Scope['layeredStates'], parent?: Scope, name?: Scope['name']);
    // Warning: (ae-forgotten-export) The symbol "Variable" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    add(name: string, variable: Variable): void;
    // (undocumented)
    assign(name: string, val: Value): void;
    // (undocumented)
    createChildScope(states?: Map<string, Variable>, name?: Scope['name']): Scope;
    // (undocumented)
    exists(name: string): boolean;
    // (undocumented)
    get(name: string): Value;
    // (undocumented)
    getAll(): Map<string, Variable>;
    // (undocumented)
    name: string;
    // (undocumented)
    opts: {
        log?(type: string, params: Record<string, any>): void;
        onUpdated?(name: string, value: Value): void;
    };
}

// @public (undocumented)
type Statement = AddAssign | Assign | Break | Continue | Definition | Each | For | Loop | Return | SubAssign;

// @public (undocumented)
type Statement_2 = AddAssign_2 | Assign_2 | Attribute_2 | Break_2 | Continue_2 | Definition_2 | Each_2 | For_2 | Loop_2 | Return_2 | SubAssign_2;

// @public (undocumented)
const STR: (str: VStr['value']) => VStr;

// @public (undocumented)
type Str = NodeBase & {
    type: 'str';
    value: string;
};

// @public (undocumented)
type Str_2 = NodeBase_2 & ChainProp & {
    type: 'str';
    value: string;
};

// @public (undocumented)
type SubAssign = NodeBase & {
    dest: Expression;
    expr: Expression;
    type: 'subAssign';
};

// @public (undocumented)
type SubAssign_2 = NodeBase_2 & {
    dest: Expression_2;
    expr: Expression_2;
    type: 'subAssign';
};

// @public (undocumented)
type Tmpl = NodeBase & {
    tmpl: (Expression | string)[];
    type: 'tmpl';
};

// @public (undocumented)
type Tmpl_2 = NodeBase_2 & ChainProp & {
    tmpl: (Expression_2 | string)[];
    type: 'tmpl';
};

// @public (undocumented)
const TRUE: {
    type: "bool";
    value: boolean;
};

// @public (undocumented)
type TypeSource = FnTypeSource | NamedTypeSource;

// @public (undocumented)
type TypeSource_2 = FnTypeSource_2 | NamedTypeSource_2;

// @public (undocumented)
const unwrapRet: (value: Value) => Value;

declare namespace Utils {
    export {
        assertArray,
        assertBoolean,
        assertFunction,
        assertNumber,
        assertObject,
        assertString,
        eq,
        expectAny,
        getLangVersion,
        isArray,
        isBoolean,
        isFunction,
        isNumber,
        isObject,
        isString,
        jsToVal,
        reprValue,
        valToJs,
        valToString
    }
}
export { Utils }

// @public (undocumented)
function valToJs(value: Value): any;

// @public (undocumented)
function valToString(value: Value, simple?: boolean): string;

// @public (undocumented)
type Value = (VArr | VBool | VBreak | VContinue | VError | VFn | VNull | VNum | VObj | VReturn | VStr) & Attr;

declare namespace Values {
    export {
        Attr,
        Value,
        VArr,
        VBool,
        VBreak,
        VContinue,
        VError,
        VFn,
        VNull,
        VNum,
        VObj,
        VReturn,
        VStr,
        ARR,
        BOOL,
        BREAK,
        CONTINUE,
        ERROR,
        FALSE,
        FN,
        FN_NATIVE,
        NULL,
        NUM,
        OBJ,
        RETURN,
        STR,
        TRUE,
        unwrapRet
    }
}
export { Values }

// @public (undocumented)
type VArr = {
    type: 'arr';
    value: Value[];
};

// @public (undocumented)
type VBool = {
    type: 'bool';
    value: boolean;
};

// @public (undocumented)
type VBreak = {
    type: 'break';
    value: null;
};

// @public (undocumented)
type VContinue = {
    type: 'continue';
    value: null;
};

// @public (undocumented)
type VError = {
    info?: Value;
    type: 'error';
    value: string;
};

// @public
type VFn = {
    args?: string[];
    native?: (args: (Value | undefined)[], opts: {
        call: (fn: VFn, args: Value[]) => Promise<Value>;
        registerAbortHandler: (handler: () => void) => void;
        topCall: (fn: VFn, args: Value[]) => Promise<Value>;
        unregisterAbortHandler: (handler: () => void) => void;
    }) => Promise<Value> | Value | void;
    scope?: Scope;
    statements?: Node[];
    type: 'fn';
};

// @public (undocumented)
type VNull = {
    type: 'null';
};

// @public (undocumented)
type VNum = {
    type: 'num';
    value: number;
};

// @public (undocumented)
type VObj = {
    type: 'obj';
    value: Map<string, Value>;
};

// @public (undocumented)
type VReturn = {
    type: 'return';
    value: Value;
};

// @public (undocumented)
type VStr = {
    type: 'str';
    value: string;
};

// (No @packageDocumentation comment for this package)

```
